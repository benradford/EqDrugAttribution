---
title: "EquationDrug Attribution"
author: "Benjamin J. Radford"
date: "March 12, 2015"
output: html_document
---

```{r, engine='python', highlight=T, echo=F}
# This code is in Python 2.7
# It uses the workalendar package to get natianal holidays for various countries.
# from datetime import date
# import csv
# import os
# from workalendar.europe import France, UnitedKingdom, Germany
# from workalendar.canada import Canada
# from workalendar.usa import UnitedStates
# from workalendar.oceania import Australia
# from workalendar.america import Brazil
# cal = {'France':France(), 'UnitedKingdom':UnitedKingdom(), 
#        'Germany':Germany(), 'Canada':Canada(), 
#        'UnitedStates':UnitedStates(), 'Australia':Australia(),
#        'Brazil':Brazil()}
# with open('temp_holidays.csv','w') as my_file:
#   csv_file = csv.writer(my_file)
#   csv_file.writerow(['date','name','country'])
#   for yy in range(2001,2013):
#     for cc in cal:
#       for dd in cal[cc].holidays(yy):
#         dd = dd + (cc,)
#         csv_file.writerow(dd)
```

# Introduction
In February 2015, Kaspersky Labs released a [report (PDF)](https://securelist.com/files/2015/02/Equation_group_questions_and_answers.pdf) detailing its investigation into the [Equation Group](https://en.wikipedia.org/wiki/Equation_Group), an extremely sophisticated cyberspace actor engaged in espionage. Many experts suspect the United States to be behind Equation Group due to keywords identified in malware the group has produced. In this article, I will use a different approach to produce evidence for attribution. Kaspersky released, in addition to it's initial report, data on the dates that pieces of malware were compiled by Equation Group. These timestamps fall almost exclusive during the working week and appear to follow a 9:00 to 5:00 schedule. Assuming that Equation Group is operated by a state actor (government), we can correlate these dates with holidays to identify countries that are more or less likely to be responsible.

# Getting Data
First, we will download holiday data for several candidate countries from [timeanddate.com](www.timeanddate.com). To do this, we'll use the [`XML`](http://cran.r-project.org/web/packages/XML/index.html) package in [`R`](http://www.r-project.org/). The candidate countries are those that are most likely to have advanced cyber capabilities as well as a few countries that fall within the [UTC-3 timezone](http://securelist.com/blog/research/69203/inside-the-equationdrug-espionage-platform/).
```{r, message=F, error=F, warning=F}
library(timeDate)
library(XML)

base.url <- "http://www.timeanddate.com/holidays"
countries <- c("russia","israel","china","iran","canada","uk","us","brazil","australia","germany","argentina")
years <- 2001:2013
holiday.list <- list()
for(yy in years)
{
  for(cc in countries)
  {
    holiday.url <- paste(base.url,cc,yy,sep="/")
    page <- htmlParse(holiday.url)
    tabs <- readHTMLTable(page, header=T)
    holiday.table <- tabs[[1]]
    holiday.table <- holiday.table[grepl("National holiday|Bank holiday|Public Holiday|Feriado Nacional",holiday.table[,4],ignore.case=T),]
    date <- paste(holiday.table[,1],yy,sep=" ")
    date <- as.Date(date, "%b %d %Y")
    name <- holiday.table[,3]
    holiday.list <- c(holiday.list,list(data.frame("date"=date,"name"=name,"country"=cc)))
    Sys.sleep(0.25)
  }
}
holiday.df <- do.call(rbind,holiday.list)
```

Next, we'll load the Equation Group's link timestamp dates into the R object `eq.dates`. These come from [Kaspersky Labs](http://securelist.com/blog/research/69203/inside-the-equationdrug-espionage-platform/). The three weekend dates observed in the Equation Group's timestamps are thrown out and our analysis assumes that the remaining weekdays are chosen at random. This is due to the fact that we have to make assumptions about the data generating process and cannot infer the day-of-week distribution from the observed data without risking post-treatment bias. Simply put, it is easiest (and, in my opinion, safest) to assume that the three weekend timestamps are outliers regardless of the country in which Equation Group is operating and that the distribution of weekday timestamps is random and uniform (controlling for holidays).
```{r, echo=T, error=F, message=F, warning=F, results='hide'}
holiday.list <- split(holiday.df, holiday.df$country)

eq.dates <- c("2001.08.17", "2007.12.11", "2009.04.16", "2011.10.20", "2012.08.31", "2013.06.11",
              "2001.08.23", "2007.12.17", "2009.06.05", "2011.10.26", "2012.09.28", "2013.06.26",
              "2003.08.16", "2008.01.01", "2009.12.15", "2012.03.06", "2012.10.23", "2013.08.09",
              "2003.08.17", "2008.01.23", "2010.01.22", "2012.03.22", "2012.11.02", "2013.08.28",
              "2005.03.16", "2008.01.24", "2010.02.19", "2012.04.03", "2012.11.06", "2013.10.16",
              "2005.09.08", "2008.01.29", "2010.02.22", "2012.04.04", "2013.01.08", "2013.11.04",
              "2006.06.15", "2008.01.30", "2010.03.27", "2012.04.05", "2013.02.07", "2013.11.26",
              "2006.09.18", "2008.04.24", "2010.06.15", "2012.04.12", "2013.02.21", "2013.12.04",
              "2006.10.04", "2008.05.07", "2011.02.09", "2012.07.02", "2013.02.22", "2013.12.05",
              "2006.10.16", "2008.05.09", "2011.02.23", "2012.07.09", "2013.02.27", "2013.12.13",
              "2007.07.12", "2008.06.17", "2011.08.08", "2012.07.17", "2013.04.16",
              "2007.10.02", "2008.09.17", "2011.08.30", "2012.08.02", "2013.05.08",
              "2007.10.16", "2008.09.24", "2011.09.02", "2012.08.03", "2013.05.14",
              "2007.12.10", "2008.12.05", "2011.10.04", "2012.08.14", "2013.05.24")
eq.dates <- as.Date(eq.dates,"%Y.%m.%d")
eq.dates <- eq.dates[isWeekday(eq.dates)]

# Set parameters
all.dates <- seq(min(eq.dates),max(eq.dates),by=1)
all.dates <- all.dates[isWeekday(all.dates)]
n <- 10000

# Simulate n link dates
sample.dates <- list()
for(ii in 1:n)
{
  week.sample <- sample(all.dates, length(eq.dates), replace=F)
  sample.dates <- c(sample.dates, list(week.sample))
}

# Calculate holiday distribution for each country
simulated.list <- list()
observed.list <- NULL
country.name <- NULL
for(cc in holiday.list)
{
  simulated.list <- c(simulated.list, list(lapply(sample.dates, FUN=function(x){sum(x %in% cc$date)})))
  observed.list <- c(observed.list, sum(eq.dates %in% cc$date))
  country.name <- c(country.name,as.character(unique(cc$country)))
}
```

Finally, we will inspect the results.
```{r, warning=F, error=F, message=F, results='hold', comment="", fig.align='center', fig.height=8, fig.width=6}
results.df <- NULL
country.name <- toupper(country.name)

par(mfrow=c(4,3), mar=c(2.1,1.1,5.1,1.1))
for(cc in 1:length(country.name))
{
  c.name <- country.name[cc]
  proportion <- mean(simulated.list[[cc]] <= observed.list[cc])
  results.df <- rbind(results.df, data.frame(Country=c.name, Probability=proportion))
  hist(as.numeric(simulated.list[[cc]]), breaks=0:max(unlist(simulated.list)), col="#aaaaaa",
       ylab="", xlab="", main=country.name[cc], yaxt="n", yaxs="i")
  abline(v=mean(as.numeric(simulated.list[[cc]])), col="blue", lwd=2)
  abline(v=observed.list[cc], col="red", lwd=2)
}
plot(0,0,type="n",xaxt="n",yaxt="n",main="",xlab="",ylab="",xlim=c(-1,1),ylim=c(0,3),frame=F)
text(0,.5,"Expected Value",col="blue")
text(0,2.5,"Observed Value",col="red")

print(results.df[order(results.df$Probability),], right=F, row.names=F)
```

This means that it is least likely for a set of dates with this few holidays to occur at random in the United States.
